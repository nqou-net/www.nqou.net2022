---
comment: false
date: 2016-12-08 20:21:41
iso8601: 2016-12-08T20:21:41+09:00
tags:
  - kansaipm
  - perl
  - yapc
title: 遅延実行と仮実行（dry_run）について考えてみた

---

<p>この記事は <a href="https://qiita.com/advent-calendar/2016/perl5">Perl 5 Advent Calendar 2016</a> の8日目の記事です。</p>

<p>昨日は <a href="https://twitter.com/wakegisky">@wakegisky</a> さんの <a href="http://wakegisky.hatenablog.com/entry/2016/12/07/000000">Perl の基礎知識で実用プログラミング 〜旅情編〜</a> でした。</p>

<p>データを追加するだけで動作がどんどん良くなる、凄い仕組みのプログラムですね。
必要は発明の母です。</p>

<p>さて、今日は関数のリファレンスを使った tips を書いてみたいと思います。</p>

<h2>遅延実行と仮実行（dry_run）</h2>

<p>シチュエーションは色々あると思いますが、実行結果を事前に確認したい、ということはよくあります。</p>

<p>コマンドとかの場合は、「--dry-run」のようなオプションがあって、そのオプションを付けると実際には何も変更しないけれども、実行した感じで結果が返ってくる。みたいな。</p>

<p>でも、これって結構面倒だと思いませんか？</p>

<p>最初からちゃんと考えて実装していれば問題ないですが、そうでもない場合は、実行しているところが色々分散していて、仮実行のときはここは変更しない、みたいなところを色々とif文などで避けなければいけない。</p>

<p>実際に実行する箇所を一つにまとめられたら楽なんじゃないかなと思いませんか？</p>

<h2>関数のリファレンスで処理をまとめる</h2>

<p>そこで登場するのが関数のリファレンスです。</p>

<p>実装のイメージとしてはこんな感じ。</p>

```
use strict;
use warnings;
use feature 'say';

my @job;
push @job, sub { say 1 };
push @job, sub { say 2 };
say "hoge";
unshift @job, sub { say 3 };
for (@job) { &{$_} }
```

<p>これを実行すると以下のようになります。</p>

```
hoge
3
1
2
```

<p>基本的な仕組みとしては、関数のリファレンスを push したり unshift したりして、配列に貯めておき、実行するときは関数のリファレンスをデリファレンスする、という感じです。</p>

<p>こうしておくと、実際の実行部分は、関数のデリファレンス部分にまとまります。</p>

<p>この仕組を利用すると、実際の書き込み処理は配列に貯めておいて、仮実行のときはこれを実行しない、というようにすることができます。</p>

```
unless ($dry_run) {
    for (@job) { &{$_} }
}
```

<p>$dry_run が真の場合、以下のように出力されます。</p>

```
hoge
```

<p>ということで、処理が各所に点在していても、仮実行の対象にしたい処理はグローバルな変数などを一つ用意して、そこにジョブ（関数のリファレンス）を貯めておき、仮実行でない場合だけ実行するようにすることができます。</p>

<p>こういった仕組みを使うと、例えば <a href="https://metacpan.org/pod/Teng">Teng</a> の場合は、値をセット（set, set_columnsなど）だけして、実際の更新処理（update）は関数のリファレンスで貯めておき、dry_runのときはupdateの処理を捨てることで、限りなく本番に近い仮実行ができるようになります。</p>

<h2>CGIにも関数のリファレンスを</h2>

<p>話は変わりますが、古き良きCGIは、スクリプトの最初にまずHTTPヘッダを出力したりしています。</p>

<p>テンプレートを使っていない場合は、その次にHTMLのヘッダを出力したりしているのではないでしょうか。</p>

<p>そうして順に処理していったところで何らかのエラーが発生した場合、突然エラーメッセージが出力されてHTMLがちぎれた状態になったりするんですよね。</p>

<p>でも、そういうのを修正するのは面倒なので、なかなか手を付けられないのではないかとおもいます。</p>

<p>そんな時に、先程の仕組みを使えば、あまり沢山のコードを書き換えなくてもよくなります。</p>

<p>print で出力しているところをグローバルな変数に関数のリファレンスとして貯めておき、エラーのときは、それまで貯めておいた処理を捨てて、エラーだけを出力する、なんてことができるようになりますよ。</p>

<h2>最後に</h2>

<p>2017年3月4日（土）に YAPC::Japan と Kansai.pm がコラボした、「YAPC::Kansai 2017 OSAKA」を開催します。</p>

<ul>
<li><a href="http://yapcjapan.org/2017kansai/">YAPC::Kansai 2017 OSAKA</a></li>
</ul>

<p>まだまだ未定なことが多いですが、今から予定を空けておいてください。</p>

<p>明日は <a href="https://qiita.com/skaji">skaji</a> さんで、「cpmについて書きます」のようです。</p>

<p>また、アドベントカレンダーには、まだ空きがありますので、何か書いてみたい方は是非ご参加ください！！</p>

<ul>
<li><a href="https://qiita.com/advent-calendar/2016/perl5">Perl 5 Advent Calendar 2016 - Qiita</a></li>
</ul>
    	